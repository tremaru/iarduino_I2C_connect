#include "iarduino_I2C_connect.h"											//
#include "Wire.h"															//
																			//
namespace _I2C2{															//	Пространство имён для функций обработчиков событий (fnc_IN, fnc_OUT) и используемых ими переменных.
	uint8_t*	arr_REG		= 0;											//	Определяем указатель на массив данных слейва, который будет доступен мастеру по шине I2C.
	uint8_t		len_REG		= 0;											//	Определяем переменную для хранения размера массива arr_REG.
	uint8_t		cnt_REG		= 0;											//	Определяем переменную для хранения активного индекса массива arr_REG.
	bool*		arr_MASK	= 0;											//	Определяем указатель на маскировочный массив (массив флагов), разрешающий мастеру запись в массив данных arr_REG по шине I2C.
	uint8_t		len_MASK	= 0;											//	Определяем переменную для хранения размера маскировочного массива.
	bool		flg_MASK	= 0;											//	Определяем флаг информирующий о наличии маскировочного массива.
	void		fnc_IN		(int);											//	Объявляем функцию обработки данных принятых    по шине I2C.
	void		fnc_OUT		(void);											//	Объявляем функцию обработки данных запрошенных по шине I2C.
}																			//
																			//
//		Функция обработки данных принятых по шине I2C:						//
void	_I2C2::fnc_IN(int i){												//	Параметр: количество принятых байт по шине I2C.
			bool f;															//	Определяем флаг разрешающий запись принятых данных в массив «arr_REG».
			uint8_t data;													//	Определяем переменную для побайтного чтения данных.
			cnt_REG=Wire.read();											//	Первый байт данных, полученный от мастера, является номером элемента массива (адресом регистра).
			for(uint8_t j=1; j<i; j++){ f=0;								//	Если получено более 1 байта данных, значит производится запись в массив (регистры).
				data=Wire.read();											//	Читаем байт данных.
				if(!flg_MASK ){							 f=1;	}			//	Если массив arr_MASK не указан, значит запись разрешена, устанавливаем флаг f.
				if( f==0     ){ if( len_MASK<cnt_REG  )	{f=1;}	}			//	Если флаг f не установлен и размер массива arr_MASK меньше активного индекса массива данных cnt_REG, значит запись разрешена, устанавливаем флаг f.
				if( f==0     ){ if( arr_MASK[cnt_REG] )	{f=1;}	}			//	Если флаг f не установлен и активный индекс cnt_REG массива arr_MASK разрешает запись, то устанавливаем флаг f.
				if( f==1     ){ arr_REG[cnt_REG]=data; 			}			//  Если запись данных в элемент cnt_REG массива данных разрешена, то сохраняем прочитанный байт данных.
				cnt_REG++; if(cnt_REG>=len_REG){cnt_REG=0;}					//	Увеличиваем значение индекса активного элемента массива arr_REG.
			}																//
}

void	_I2C2::fnc_OUT(void){												//	без параметра
			if(cnt_REG>=len_REG){cnt_REG=0;}								//	корректируем значение индекса активного элемента массива arr_REG, если он вышел за его пределы
			Wire.write(arr_REG[cnt_REG]);									//	читаем значение активного элемента массива arr_REG (элемент на который указывает индекс cnt_REG)
			cnt_REG++;														//	увеличиваем значение индекса активного элемента массива arr_REG
}

//		указание массива
void	iarduino_I2C_connect::I2C_func_BEGIN(uint8_t* i, uint8_t j){		//	указатель на массив, длина массива
			_I2C2::arr_REG=i;												//	сохраняем указатель
			_I2C2::len_REG=j;												//	сохраняем длину
			Wire.onReceive(_I2C2::fnc_IN);									//	назначаем функцию для обработки принятых по шине I2C данных
			Wire.onRequest(_I2C2::fnc_OUT);									//	назначаем функцию для обработки запрошенных по шине I2C данных
}

//		указание маскировочного массива
void	iarduino_I2C_connect::I2C_func_MASK(bool* i, uint8_t j){			//	указатель на маскировочный массив, длина маскировочного массива
			_I2C2::arr_MASK=i;												//	сохраняем указатель
			_I2C2::len_MASK=j;												//	сохраняем длину
			_I2C2::flg_MASK=1;												//	устанавливаем флаг указания маскировочного массива
}

//		чтение одного байта данных из устройства с указанием
byte	iarduino_I2C_connect::readByte(byte i, byte j){						//	адрес устройства, адрес регистра
			byte k=0;														//	переменная для ответа
			Wire.beginTransmission(i);										//	инициируем передачу данных по шине I2C к устройству с адресом i (При этом сама передача не начинается)
			Wire.write(j);													//	указываем, что требуется передать байт j - адрес регистра из которого требуется прочитать данные
			Wire.endTransmission(true);										//	выполняем инициированную передачу данных (бит RW=0 => запись)
			if(Wire.requestFrom(i,uint8_t(1))){								//	запрашиваем 1 байт данных от устройства с адресом i, функция Wire.requestFrom() возвращает количество принятых байтов
				while(Wire.available()){k=Wire.read();}						//	читаем очередной принятый байт, если таковой имеется в буфере для чтения
			}	return k;													//	возвращаем последний принятый байт данных
}

//		запись одного байта
byte	iarduino_I2C_connect::writeByte(byte i, byte j, byte k){			//	адрес устройства, адрес регистра, байт для записи
			Wire.beginTransmission(i);										//	инициируем передачу данных по шине I2C к устройству с адресом i (При этом сама передача не начинается)
			Wire.write(j);													//	указываем, что требуется передать байт j - адрес регистра из которого требуется прочитать данные
			Wire.write(k);													//	указываем, что требуется передать байт k - данные для записи в регистр j устройства i
			return Wire.endTransmission();									//	выполняем инициированную передачу данных (бит RW=0 => запись)
}
