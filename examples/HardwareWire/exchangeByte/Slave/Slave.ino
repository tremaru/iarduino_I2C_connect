//   ПРИМЕР ВЕДОМОГО УСТРОЙСТВА:                                              // * Строки со звёздочкой являются необязательными.
//   Организация передачи байтов через массив arr_Data:                       //
                                                                              //
//   ВАЖНО: Установите подтягивающие резисторы на линии SCL и SDA!            //   Внутрисхемная подтяжка микроконтроллера осуществляется высокоомным сопротивлением, не гарантирующим устойчивость от помех.
                                                                              //
#include <Wire.h>                                                             //   Подключаем библиотеку для работы с аппаратной шиной I2C, до подключения библиотеки iarduino_I2C_connect.
#include <iarduino_I2C_connect.h>                                             //   Подключаем библиотеку для соединения Arduino по шине I2C.
                                                                              //
iarduino_I2C_connect obj;                                                     //   Создаём объект obj для работы c методами библиотеки iarduino_I2C_connect.
                                                                              //
byte arr_Data[10]={0,1,2,3,4,5,6,7,8,9};                                      //   Определяем массив данных из 10 элементов (максимально допустимый размер 255 элементов).
bool arr_Mask[8 ]={1,1,1,1,1,1,0,1};                                          // * Определяем маскировочный массив из 8 флагов. Если флаг сброшен, то он запрещает мастеру запись в массив данных.
                                                                              //   В данном случае мы запрещаем мастеру запись в 6 элемент массива arr_Data.
                                                                              //   Обратите внимание что для элементов массива arr_Data 8 и 9 нет флагов, значит запись не запрещена.
void setup(){                                                                 //
     Serial.begin(9600);                                                      //   Инициируем передачу данных по шине UART в монитор последовательного порта на скорости 9600 бит/сек.
//   Создаём роль ведомого на шине I2C с адресом 0x09:                        //
     Wire.begin(0x09);                                                        //   Инициируем подключение к шине I2C в качестве ведомого (slave), с указанием его адреса на шине (0x09).
//   Теперь данная плата стала ведомым устройством с адресом 0x09.            //
//   Разрешаем доступ мастеру к массиву данных arr_Data по шине I2C:          //
     obj.begin(&Wire , arr_Data, arr_Mask);                                   //   Инициируем возможность чтения/записи данных, указав: ссылку на объект шины I2C, массив данных arr_Data, маскировочный массив arr_Mask.
//   obj.begin(&Wire , arr_Data          );                                   //   Можно не указывать маскировочный массив arr_Mask, тогда все элементы массива данных arr_Data будут доступны мастеру для записи.
//   obj.begin(&Wire1, arr_Data, arr_Mask);                                   //   Можно указать ссылку на объект для работы с любой аппаратной шиной I2C: &Wire, &Wire1, &Wire2...
//   obj.begin(        arr_Data, arr_Mask);                                   //   Если объект работы с шиной I2C не указан, то будет использован объект по умолчанию (&Wire).
//   Теперь мастер может читать данные из любых элементов массива arr_Data.   //
//   Мастер может записывать данные только в те элементы массива arr_Data,    //
//   которые не запрещены маскировочным массивом arr_Mask.                    //
//   Разумеется, оба массива доступны для чтения/записи в этом скетче.        //
}                                                                             //
                                                                              //
//   Массив arr_Data имеет тип byte и его можно заполнять только байтами.     //
//   Для мастера, номер элемента массива будет совпадать с номером регистра.  //
//   В примере "exchangeMulti" описана передача значений int, float и т.д.    //
                                                                              //
void loop(){                                                                  //
//   Один раз в 5 секунд:                                                     //
     if( millis()%5000==0 ){                                                  //
         delay(1);                                                            //   Без задержки, условие ( millis()%5000==0 ) выполнится несколько раз.
     //  Меняем значения всего массива arr_Data:                              //
         for(uint8_t i=0; i<10; i++){ arr_Data[i]=i; }                        //   arr_Data = {0,1,2,3,4,5,6,7,8,9}
     }                                                                        //
//   Один раз в секунду:                                                      //
     if( millis()%1000==1 ){                                                  //   В условии время сравнивается с 1, т.к. в предыдущем условии была задержка на 1 мс.
         delay(1);                                                            // * В данном случае задержку можно не ставить, т.к. вывод массива на экран, на скорости 9600, займет больше 1 мс.
     //  Выводим все элементы массива arr_Data:                               //
         for(uint8_t i=0; i<10; i++){                                         //
         //  Выводим запятую и ведущие нули:                                  //
             if( i               ){ Serial.print(", "); }                     //
             if( arr_Data[i]<100 ){ Serial.print(0);    }                     // *
             if( arr_Data[i]< 10 ){ Serial.print(0);    }                     // *
         //  Выводим очередной элемент массива данных:                        //
             Serial.print( arr_Data[i] );                                     //
         }   Serial.println();                                                //
     }                                                                        //
}                                                                             //
                                                                              //
//   В примере "exchangeByte/Master" мастер ждёт когда изменятся значения     //
//   регистров ведомого и через 2 секунды после этого, сам меняет их.         //
//   Значит мы должны видеть 2 секунды одни значения и 3 секунды другие.      //
//   Обратите внимание на то, что значение arr_Data[6] не меняется, так как   //
//   мы запретили доступ мастера к записи в этот элемент, массивом arr_Mask.  //

/*   ФУНКЦИИ БИБЛИОТЕКИ ДЛЯ ВЕДОМОГО:
 *   begin    ( [&объект I2C] , массив данных [, маскировочный массив] );     // Инициализации доступа к массиву данных по шине I2C.
 *   writeMask( маскировочный массив );                                       // Устаревшая функция указания маскировочного массива.
 *   
 *   Функцию begin() достаточно вызвать один раз в коде setup().
 *   Функция позволяет мастеру обращается к элементам массива данных как к регистрам ведомого по шине I2C.
 *   Маскировочный массив позволяет запретить запись в конкретные элементы массива данных по шине I2C.
 *   Если маскировочный массив не указан, то доступ на запись не ограничен.
 *   Если объект для работы с шиной I2C не указан, то используется &Wire.
 *
 *   ФУНКЦИИ БИБЛИОТЕКИ ДЛЯ МАСТЕРА:
 *   begin     ( &объект I2C );                        // Необязательная функция указания рабочей шины I2C.
 *   readByte  ( адрес, регистр );                     // Чтение одного    байта по шине I2C. Указывается адрес модуля и номер регистра.
 *   writeByte ( адрес, регистр, байт );               // Запись одного    байта по шине I2C. Указывается адрес модуля , номер регистра и байт для записи.
 *   readBytes ( адрес, регистр, массив, количество ); // Чтения нескольких байт по шине I2C. Указывается адрес модуля , номер первого регистра, массив для чтения данных, количество читаемых байт.
 *   writeBytes( адрес, регистр, массив, количество ); // Запись нескольких байт по шине I2C. Указывается адрес модуля , номер первого регистра, массив для записи данных, количество записываемых байт.
 * 
 *   Функцию begin() достаточно вызвать один раз в коде setup().
 *   Если функция begin() не вызвана, то используется шина I2C под управлением объекта &Wire.
 *   Функции readByte(), readBytes(), writeByte(), writeBytes() позволяют мастеру читать/записать данные, даже если ведомое является реальным устройством, а не Arduino с библиотекой iarduino_I2C_connect.
 */