// Скетч мастера на шине I2C:           // ДЛЯ ПЛАТ ESP БИБЛИОТЕКОЙ ПОДДЕРЖИВАЕТСЯ ТОЛЬКО РЕЖИМ МАСТЕРА!
                                        //
#include <Wire.h>                       // Подключаем библиотеку для работы с шиной I2C.
#include <iarduino_I2C_connect.h>       // Подключаем библиотеку для соединения Arduino по шине I2C.
                                        //
iarduino_I2C_connect obj;               // Создаём объект obj для работы c методами библиотеки iarduino_I2C_connect.
                                        //
void setup(){                           //
     Wire.begin();                      // Инициируем подключение к шине I2C в качестве ведущего (master) устройства.
}                                       //
                                        //
void loop(){                            //
     byte i = obj.readByte(0x09, 5);    // Читаем  от ведомомо с адресом 0x09 значение из его 5 регистра в переменную i.
     obj.writeByte(0x09, 0, i);         // Записываем ведомому с адресом 0x09 в его 0 регистр значение из переменной i.
     obj.writeByte(0x09, 4, 255);       // Записываем ведомому с адресом 0x09 в его 4 регистр значение 255.
     obj.writeByte(0x09, 6, 255);       // Записываем ведомому с адресом 0x09 в его 6 регистр значение 255.
//   Задержка:                          //
     delay(500);                        // Выполняем задержку, чтоб не слишком часто читать и записывать значения регистров ведомого.
}                                       //

// Данный скетч реализует работу Arduino в качестве мастера на шине I2C.
// В скетче мастер обращается к одному ведому устройству с адресом 0x09. Хотя можно обращаться к разным ведомым с разными адресами.
// С каждым проходом цикла loop() мастер читает байт из 5 регистра ведомого и записывает его в 0 регистр ведомого.
// Далее мастер записывает значение 255 в 4 и 6 регистры ведомого.

// Если в качестве ведомого устройства будет выступать Arduino с загруженным скетчем "example_slave" из примеров данной библиотеки, то ...
// В мониторе последовательного порта ведомого будут появляться строки со всеми элементами его массива данных.
// Значение 5 элемента массива постоянно увеличивается, это делается в коде слейва.
// Значение 0 элемента массива будет совпадать со значением 5 элемента. Но если отключить мастера от шины I2C, то это значение перестанет увеличиваться.
// Значение 4 элемента массива будет равно 4, а не 255, так как маскировочный массив слейва запрещает мастеру менять 4 и 5 элементы массива.
// Значение 6 элемента массива будет равно 255. Но если отключить мастера от шины I2C, то это значение обнулится в течении 1 секунды.

/* ВСЕ ФУНКЦИИ БИБЛИОТЕКИ:            - Библиотека iarduino_I2C_connect разработана для удобства соединения нескольких arduino по шине I2C.
 * 
 * begin( массив данных );            - ФУНКЦИЯ ТОЛЬКО ДЛЯ ВЕДОМОГО. Функцию достаточно вызвать один раз в коде setup().
 *                                      Функция предназначена для инициализации чтения/записи данных указанного массива по шине I2C.
 *                                      Данные указанного массива можно читать и менять как в этом скетче, так и по шине I2C.
 *                                      Мастер обращается к элементам массива данных как к регистрам ведомого,
 *                                      номера элементов этого массива (индексы) совпадают с номерами регистров этого ведомого.
 *                                      Скетч мастера можно создать без библиотеки iarduino_I2C_connect,
 *                                      реализовав чтение/запись обычными функциями библиотеки Wire.
 *
 * writeMask( маскировочный массив ); - ФУНКЦИЯ ТОЛЬКО ДЛЯ ВЕДОМОГО. Функйию достаточно вызвать один раз в коде setup().
 *                                      Функция позволяет ограничить запись в массив данных по шине I2C.
 *                                      Функция принимает маскировочный массив типа bool, данные которого являются флагами.
 *                                      Каждый элемент маскировочного массива является флагом разрешающим мастеру
 *                                      запись в тот же элемент массива данных (в элемент с тем же индексом) см. пример.
 *                                      Если не обращаться к функции writeMask(), то все элементы массива данных
 *                                      будут доступны мастеру, как для чтения, так и для записи.
 *
 * readByte( адрес, регистр );        - ФУНКЦИЯ ТОЛЬКО ДЛЯ МАСТЕРА.
 *                                      Функция позволяет мастеру прочитать один байт по шине I2C от ведомого устройства,
 *                                      даже если это реальное устройство, а не Arduino с библиотекой iarduino_I2C_connect.
 *                                      Функция принимает адрес ведомого устройства на шине I2C (0x01...0x7F) и
 *                                      номер регистра ведомого устройства (0...255), данные которого требуется прочитать.
 *                                      Функция возвращает прочитанный из регистра байт данных.
 *
 * writeByte( адрес, регистр, байт ); - ФУНКЦИЯ ТОЛЬКО ДЛЯ МАСТЕРА.
 *                                      Функция позволяет мастеру записать один байт по шине I2C в регистр ведомого устройства,
 *                                      даже если это реальное устройство, а не Arduino с библиотекой iarduino_I2C_connect.
 *                                      Функция принимает адрес ведомого устройства на шине I2C (0x01...0x7F),
 *                                      номер регистра ведомого устройства (0...255), 
 *                                      байт данных который требуется записать в указанный регистр.
 *                                      Функция возвращает результат операции записи, как функция Wire.endTransmission().
 */