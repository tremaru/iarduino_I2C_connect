#include "iarduino_I2C_connect.h"											//
																			//
//		ПРОСТРАНСТВО ИМЁН ДЛЯ ФУНКЦИЙ ОБРАБОТКИ ПРЕРЫВАНИЙ ВНЕ КЛАССА:		//
namespace iarduino_I2C_connect_NS{											//	Создаём пространство имён для функций fnc_IN(), fnc_OUT() и используемых ими переменных:
	byte*					arr_REG		= 0;								//	Определяем указатель на массив данных слейва, который будет доступен мастеру по шине I2C.
	uint8_t					len_REG		= 0;								//	Определяем переменную для хранения размера массива arr_REG.
	uint8_t					cnt_REG		= 0;								//	Определяем переменную для хранения активного индекса массива arr_REG.
	bool*					arr_MASK	= 0;								//	Определяем указатель на маскировочный массив (массив флагов), разрешающий мастеру запись в массив данных arr_REG по шине I2C.
	uint8_t					len_MASK	= 0;								//	Определяем переменную для хранения размера маскировочного массива.
	bool					flg_MASK	= 0;								//	Определяем флаг информирующий о наличии маскировочного массива.
	void					fnc_IN		(int);								//	Объявляем функцию обработки данных принятых    по шине I2C.
	void					fnc_OUT		(void);								//	Объявляем функцию обработки данных запрошенных по шине I2C.
	iarduino_I2C_Select*	ptr_I2C;										//	Объявляем указатель для работы с выбранной шиной I2C в пространстве имён iarduino_I2C_connect_NS.
}																			//
																			//
//		ФУНКЦИЯ СОХРАНЕНИЯ УКАЗАТЕЛЯ I2C ДЛЯ ПРЕРЫВАНИЙ:					//
void	iarduino_I2C_connect::_savePtrI2C(iarduino_I2C_Select* obj){		//
			iarduino_I2C_connect_NS::ptr_I2C=obj;							//	Сохраняем указатель iarduino_I2C_Select* в пространство имён iarduino_I2C_connect_NS.
}																			//
																			//
//		ФУНКЦИЯ ОБРАБОТКИ ДАННЫХ ПРИНЯТЫХ ВЕДОМЫМ ОТ МАСТЕРА ПО ШИНЕ I2C:	//
void	iarduino_I2C_connect_NS::fnc_IN(int i){								//	Параметр: количество принятых байт по шине I2C.
		//	Сохраняем номер активного элемента массива:						//
			cnt_REG=ptr_I2C->read();										//	Первый байт данных, полученный от мастера, является номером элемента массива (адресом регистра).
		//	Сохраняем данные в массив:										//
			for(uint8_t j=1; j<i; j++){										//	Если получено более 1 байта данных, значит производится запись в массив (регистры).
			//	Читаем значение очередного полученного байта:				//
				uint8_t data=ptr_I2C->read();								//	Читаем байт данных.
			//	Проверяем разрешение записи маскировочным массивом:			//
				bool f=false;												//	Определяем флаг разрешающий запись принятых данных в массив arr_REG.
				if( !flg_MASK         ){ f=true; }							//	Если массив arr_MASK не указан, значит запись разрешена.
				if( len_MASK<cnt_REG  ){ f=true; }							//	Если размер arr_MASK меньше номера активного элемента массива данных, значит запись разрешена.
				if( arr_MASK[cnt_REG] ){ f=true; }							//	Если массив arr_MASK разрешает запись в активный элемент массива данных, значит запись разрешена.
			//	Выполняем запись полученного байта в массив данных:			//
				if( f ){ arr_REG[cnt_REG]=data;  }							//  Если флаг разрешения записи установлен, то сохраняем прочитанный байт данных.
				cnt_REG++; if( cnt_REG>=len_REG ){ cnt_REG=0; }				//	Увеличиваем индекс активного элемента массива arr_REG, со сбросом при достижении конца массива.
			}																//
}																			//
																			//
//		ФУНКЦИЯ ОБРАБОТКИ ЗАПРОСА МАСТЕРА НА ПОЛУЧЕНИЕ БАЙТА ПО ШИНЕ I2C:	//
void	iarduino_I2C_connect_NS::fnc_OUT(void){								//
		//	Проверяем индекс активного элемента массива:					//
			if( cnt_REG>=len_REG ){cnt_REG=0; }								//	Корректируем значение индекса активного элемента массива arr_REG, если он вышел за его пределы.
		//	Отправляем значение активного элемента массива:					//
			ptr_I2C->write( arr_REG[cnt_REG] );								//	Читаем значение активного элемента массива arr_REG (элемент на который указывает индекс cnt_REG).
			cnt_REG++; if( cnt_REG>=len_REG ){ cnt_REG=0; }					//	Увеличиваем индекс активного элемента массива arr_REG, со сбросом при достижении конца массива.
}																			//
																			//
//		ФУНКЦИЯ ИНИЦИАЛИЗАЦИИ РАБОТЫ В КАЧЕСТВЕ ВЕДОМОГО:					//
void	iarduino_I2C_connect::_beginSlave(byte* i, uint8_t j){				//	Параметры: i - указатель на массив ведомого, j - длина массива ведомого.
			flgBegS=true;													//	Устанавливаем флаг инициализации работы в качестве ведомого.
		//	Инициируем работу с шиной I2C:									//
			if( flgAddr ){ selI2C->begin(valAddr); }						//	Если в конструкторе был указан адрес ведомого, то инициируем работу с выбранной шиной I2C в качестве ведомого.
		//	Сохраняем указатель и длину массива данных ведомого:			//
			iarduino_I2C_connect_NS::arr_REG=i;								//	Сохраняем указатель.
			iarduino_I2C_connect_NS::len_REG=j;								//	Сохраняем длину.
		//	Назначаем функции обработки событий ведомого:					//
			selI2C->onReceive(iarduino_I2C_connect_NS::fnc_IN);				//	Назначаем функцию для обработки ведомым принятых по шине I2C данных.
			selI2C->onRequest(iarduino_I2C_connect_NS::fnc_OUT);			//	Назначаем функцию для обработки ведомым запрошенных по шине I2C данных.
}																			//
																			//
//		ФУНКЦИЯ УКАЗАНИЯ МАСКИРОВОЧНОГО МАССИВА ВЕДОМОГО:					//
void	iarduino_I2C_connect::_setMask(bool* i, uint8_t j){					//	Параметры: i - указатель на маскировочный массив, j - длина маскировочного массива.
		//	Сохраняем указатель и длину маскировочного массива ведомого:	//
			iarduino_I2C_connect_NS::arr_MASK=i;							//	Сохраняем указатель.
			iarduino_I2C_connect_NS::len_MASK=j;							//	Сохраняем длину.
			iarduino_I2C_connect_NS::flg_MASK=1;							//	Устанавливаем флаг указания маскировочного массива.
}																			//
																			//
//		ФУНКЦИЯ ЧТЕНИЯ МАСТЕРОМ ОДНОГО БАЙТА ПО ШИНЕ I2C:					//
byte	iarduino_I2C_connect::readByte(byte i, byte j){						//	Параметры: i - адрес устройства, j - адрес регистра
			if(!flgInitM && !flgBegS){ _initMaster(); }						//	Указываем мастеру шину I2C по умолчпнию (для совместимости с библиотекой версии 1.1.1 и ниже).
					iarduino_I2C_connect_NS::ptr_I2C->readByte(i,j);		//	При чтении из ведомых организаванных на платах ESP32 наблюдается кеширование байта, по этому предварительно читаем один байт. (ошибка по состоянию на 30.05.2024)
			return	iarduino_I2C_connect_NS::ptr_I2C->readByte(i,j);		//
}																			//
																			//
//		ФУНКЦИЯ ЗАПИСИ МАСТЕРОМ ОДНОГО БАЙТА ПО ШИНЕ I2C:					//
byte	iarduino_I2C_connect::writeByte(byte i, byte j, byte k){			//	Параметры: i - адрес устройства, j - адрес регистра, k - байт для записи
			if(!flgInitM && !flgBegS){ _initMaster(); }						//	Указываем мастеру шину I2C по умолчпнию (для совместимости с библиотекой версии 1.1.1 и ниже).
			return iarduino_I2C_connect_NS::ptr_I2C->writeByte(i,j,k);		//
}																			//
																			//
//		ФУНКЦИЯ ЧТЕНИЯ МАСТЕРОМ НЕСКОЛЬКИХ БАЙТ ПО ШИНЕ I2C:				//
bool	iarduino_I2C_connect::readBytes(byte i, byte j, byte* k, byte n){	//	Параметры: i - адрес устройства, j - адрес первого регистра, k - массив для чтения данных, n - количество читаемых байт.
			if(!flgInitM && !flgBegS){ _initMaster(); }						//	Указываем мастеру шину I2C по умолчпнию (для совместимости с библиотекой версии 1.1.1 и ниже).
					iarduino_I2C_connect_NS::ptr_I2C->readByte (i,j);		//	При чтении из ведомых организаванных на платах ESP32 наблюдается кеширование байта, по этому предварительно читаем один байт. (ошибка по состоянию на 30.05.2024)
			return	iarduino_I2C_connect_NS::ptr_I2C->readBytes(i,j,k,n);	//
}																			//
																			//
//		ФУНКЦИЯ ЗАПИСИ МАСТЕРОМ НЕСКОЛЬКИХ БАЙТ ПО ШИНЕ I2C:				//
bool	iarduino_I2C_connect::writeBytes(byte i, byte j, byte* k, byte n){	//	Параметры: i - адрес устройства, j - адрес первого регистра, k - массив для записи данных, n - количество записываемых байт.
			if(!flgInitM && !flgBegS){ _initMaster(); }						//	Указываем мастеру шину I2C по умолчпнию (для совместимости с библиотекой версии 1.1.1 и ниже).
			return iarduino_I2C_connect_NS::ptr_I2C->writeBytes(i,j,k,n);	//
}																			//
