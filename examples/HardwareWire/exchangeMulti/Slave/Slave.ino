//   ПРИМЕР ВЕДОМОГО УСТРОЙСТВА:                                              // * Строки со звёздочкой являются необязательными.
//   Организация передачи данных через массив arr_Data:                       //
//   элемент  arr_Data[ 0 ]   позволяет мастеру читать значение byte.         //
//   элемент  arr_Data[ 1 ]   получает от мастера значение типа byte.         //
//   элементы arr_Data[2:3]   получают от мастера значение типа int16_t.      //
//   элементы arr_Data[4:5]   защищены от записи.                             //
//   элементы arr_Data[6:9]   получают от мастера значение типа float.        //
//   элементы arr_Data[10:11] позволяют мастеру читать значение uint16_t.     //
//   Один и тот же элемент массива может менять как ведомый, так и мастер.    //
                                                                              //
//   ВАЖНО: Установите подтягивающие резисторы на линии SCL и SDA!            //   Внутрисхемная подтяжка микроконтроллера осуществляется высокоомным сопротивлением, не гарантирующим устойчивость от помех.
                                                                              //
#include <Wire.h>                                                             //   Подключаем библиотеку для работы с аппаратной шиной I2C, до подключения библиотеки iarduino_I2C_connect.
#include <iarduino_I2C_connect.h>                                             //   Подключаем библиотеку для соединения Arduino по шине I2C.
                                                                              //
iarduino_I2C_connect obj;                                                     //   Создаём объект obj для работы c методами библиотеки iarduino_I2C_connect.
                                                                              //
byte arr_Data[12]={0,1,2,3,4,5,6,7,8,9,10,11};                                //   Определяем массив данных из 12 элементов (максимально допустимый размер 255 элементов).
bool arr_Mask[12]={1,1,1,1,0,0,1,1,1,1      };                                // * Определяем маскировочный массив из 10 флагов. Если флаг сброшен, то он запрещает мастеру запись в массив данных.
                                                                              //   В данном случае мы запрещаем мастеру запись в элементы 4 и 5 массива arr_Data.
                                                                              //   Обратите внимание что для элементов массива arr_Data 10 и 11 нет флагов, значит запись не запрещена.
void setup(){                                                                 //
     Serial.begin(9600);                                                      //   Инициируем передачу данных по шине UART в монитор последовательного порта на скорости 9600 бит/сек.
//   Создаём роль ведомого на шине I2C с адресом 0x09:                        //
     Wire.begin(0x09);                                                        //   Инициируем подключение к шине I2C в качестве ведомого (slave), с указанием его адреса на шине (0x09).
//   Теперь данная плата стала ведомым устройством с адресом 0x09.            //
//   Разрешаем доступ мастеру к массиву данных arr_Data по шине I2C:          //
     obj.begin(&Wire , arr_Data, arr_Mask);                                   //   Инициируем возможность чтения/записи данных, указав: ссылку на объект шины I2C, массив данных arr_Data, маскировочный массив arr_Mask.
//   obj.begin(&Wire , arr_Data          );                                   //   Можно не указывать маскировочный массив arr_Mask, тогда все элементы массива данных arr_Data будут доступны мастеру для записи.
//   obj.begin(&Wire1, arr_Data, arr_Mask);                                   //   Можно указать ссылку на объект для работы с любой аппаратной шиной I2C: &Wire, &Wire1, &Wire2...
//   obj.begin(        arr_Data, arr_Mask);                                   //   Если объект работы с шиной I2C не указан, то будет использован объект по умолчанию (&Wire).
//   Теперь мастер может читать данные из любых элементов массива arr_Data.   //
//   Мастер может записывать данные только в те элементы массива arr_Data,    //
//   которые не запрещены маскировочным массивом arr_Mask.                    //
//   Разумеется, оба массива доступны для чтения/записи в этом скетче.        //
}                                                                             //
                                                                              //
//   Массив arr_Data имеет тип byte и его можно заполнять только байтами.     //
//   Для мастера, номер элемента массива будет совпадать с номером регистра.  //
//   Если нужно передать иные значения (int, float и т.д.) которые занимают   //
//   несколько байт, их записывают в несколько элементов массива arr_Data.    //
//   В этом примере из элементов массива 2 и 3 собирается число типа int16_t, //
//   из четырёх элементов массива 6, 7, 8 и 9 собирается число типа float,    //
//   а на два элемента массива 10 и 11 разбирается число типа uint16_t.       //
//   Вы сами решаете, какие числа передавать и в каких элементах их хранить!  //
//   В примере для мастера, из тех же регистров собираются те же типы чисел.  //
                                                                              //
void loop(){                                                                  //
     Serial.println("-------------------------------------");                 //
     arr_Data[0]++;                                                           //   Увеличиваем значение arr_Data[0]. Мастер будет считать изменение этого значения как команду к действиям, см. пример "exchangeMulti/Master".
//   Выводим элементы 0 и 1 как байты (без изменений):                        //
     Serial.print("arr_Data[ 0 ] = ( byte  ) "); Serial.println(arr_Data[0]); //   Выводим значение arr_Data[0] как один байт данных.
     Serial.print("arr_Data[ 1 ] = ( byte  ) "); Serial.println(arr_Data[1]); //   Выводим значение arr_Data[1] как один байт данных.
//   Выводим элементы 2 и 3 как одно число типа int16_t:                      //   Число int16_t занимает 2 байта.
     int16_t i;                                                               //   Создаём переменную типа int16_t, для сборки одного числа из 2 байт массива.
     *((byte*)(&i)+0) = arr_Data[2];                                          //   Сохраняем значение arr_Data[2] как младший байт переменной i.
     *((byte*)(&i)+1) = arr_Data[3];                                          //   Сохраняем значение arr_Data[3] как старший байт переменной i.
//   i = ((int16_t)arr_Data[3]<<8)|(int16_t)arr_Data[2];                      // * Предыдущие 2 строки можно заменить на эту: сдвигаем старший байт (arr_Data[3]) на восемь бит влево и добавляем младший байт (arr_Data[2]).
     Serial.print("arr_Data[2:3] = (int16_t) "); Serial.println(i);           //   Выводим полученное значение.
//   Выводим элементы 4 и 5 которые недоступны мастеру для записи:            // * В маскировочном массиве arr_Mask элементы 4 и 5 сброшены в 0, значит ведомый игнорирует запись мастера в элементы 4 и 5 массива arr_Data.
     Serial.print("arr_Data[ 4 ] = ( byte  ) "); Serial.println(arr_Data[4]); // * Выводим значение arr_Data[4] как один байт данных.
     Serial.print("arr_Data[ 5 ] = ( byte  ) "); Serial.println(arr_Data[5]); // * Выводим значение arr_Data[5] как один байт данных.
//   Выводим элементы 6-9 как число типа float:                               //   Число типа float занимает 4 байта.
     float j;                                                                 //   Создаём переменную типа float, для сборки одного числа из 4 байт массива.
     *((byte*)(&j)+0) = arr_Data[6];                                          //   Сохраняем значение arr_Data[6] как младший байт переменной j.
     *((byte*)(&j)+1) = arr_Data[7];                                          //   Сохраняем значение arr_Data[7] как второй  байт переменной j.
     *((byte*)(&j)+2) = arr_Data[8];                                          //   Сохраняем значение arr_Data[8] как третий  байт переменной j.
     *((byte*)(&j)+3) = arr_Data[9];                                          //   Сохраняем значение arr_Data[9] как старший байт переменной j.
     Serial.print("arr_Data[6:9] = ( float ) "); Serial.println(j);           //   Выводим полученное значение.
//   Записываем число типа uint16_t в элементы 10-11 массива данных:          //
     uint16_t k = millis();                                                   //   Число uint16_t занимает 2 байта.
     arr_Data[10] = *((byte*)(&k)+0);                                         //   Сохраняем значение младшего байта числа k в 10 элемент массива arr_Data.
     arr_Data[11] = *((byte*)(&k)+1);                                         //   Сохраняем значение старшего байта числа k в 11 элемент массива arr_Data.
     Serial.print("arr_Data[a:b] = (uint16t) "); Serial.println(k);           //   Выводим полученное значение.
//   Задержка:                                                                //
     delay(1000);                                                             // * Выполняем задержку, чтоб не захломлять экран монитора.
}                                                                             //
                                                                              //
//   Теперь мастер, по шине I2C, может обращаться к ведомому с адресом 0x09.  //
//   Мастер может читать любой из 12 регистров этого ведомого.                //
//   Номер регистра совпадает с номером элемента массива данных arr_Data.     //
//   В примере "exchangeMulti/Master" мастер ждёт когда ведомый изменит байт  //
//   0 регистра и только тогда читает/записывает данные остальных регистров.  //

/*   ФУНКЦИИ БИБЛИОТЕКИ ДЛЯ ВЕДОМОГО:
 *   begin    ( [&объект I2C] , массив данных [, маскировочный массив] );     // Инициализации доступа к массиву данных по шине I2C.
 *   writeMask( маскировочный массив );                                       // Устаревшая функция указания маскировочного массива.
 *   
 *   Функцию begin() достаточно вызвать один раз в коде setup().
 *   Функция позволяет мастеру обращается к элементам массива данных как к регистрам ведомого по шине I2C.
 *   Маскировочный массив позволяет запретить запись в конкретные элементы массива данных по шине I2C.
 *   Если маскировочный массив не указан, то доступ на запись не ограничен.
 *   Если объект для работы с шиной I2C не указан, то используется &Wire.
 *
 *   ФУНКЦИИ БИБЛИОТЕКИ ДЛЯ МАСТЕРА:
 *   begin     ( &объект I2C );                        // Необязательная функция указания рабочей шины I2C.
 *   readByte  ( адрес, регистр );                     // Чтение одного    байта по шине I2C. Указывается адрес модуля и номер регистра.
 *   writeByte ( адрес, регистр, байт );               // Запись одного    байта по шине I2C. Указывается адрес модуля , номер регистра и байт для записи.
 *   readBytes ( адрес, регистр, массив, количество ); // Чтения нескольких байт по шине I2C. Указывается адрес модуля , номер первого регистра, массив для чтения данных, количество читаемых байт.
 *   writeBytes( адрес, регистр, массив, количество ); // Запись нескольких байт по шине I2C. Указывается адрес модуля , номер первого регистра, массив для записи данных, количество записываемых байт.
 * 
 *   Функцию begin() достаточно вызвать один раз в коде setup().
 *   Если функция begin() не вызвана, то используется шина I2C под управлением объекта &Wire.
 *   Функции readByte(), readBytes(), writeByte(), writeBytes() позволяют мастеру читать/записать данные, даже если ведомое является реальным устройством, а не Arduino с библиотекой iarduino_I2C_connect.
 */