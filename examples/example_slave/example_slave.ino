// Скетч ведомого устройства:           // ДЛЯ ПЛАТ ESP БИБЛИОТЕКОЙ ПОДДЕРЖИВАЕТСЯ ТОЛЬКО РЕЖИМ МАСТЕРА!
                                        //
#include <Wire.h>                       // Подключаем библиотеку для работы с шиной I2C.
#include <iarduino_I2C_connect.h>       // Подключаем библиотеку для соединения Arduino по шине I2C.
                                        //
iarduino_I2C_connect obj;               // Создаём объект obj для работы c методами библиотеки iarduino_I2C_connect.
byte arr_Data[]={0,1,2,3,4,5,6,7,8,9};  // Определяем массив данных из 10 элементов (максимально допустимый размер 255 элементов).
bool arr_Mask[]={1,1,1,1,0,0,1,1,1,1};  // Определяем маскировочный массив из 10 флагов которые разрешают мастеру запись в массив данных.
                                        // В данном случае мы разрешаем мастеру запись во все элементы массива arr_Data кроме 4 и 5.
void setup(){                           //
//   Готовим шины к работе:             //
     Serial.begin(9600);                // Инициируем передачу данных по шине UART в монитор последовательного порта на скорости 9600 бит/сек.
     Wire.begin(0x09);                  // Инициируем подключение к шине I2C в качестве ведомого (slave), с указанием его адреса на шине (0x09).
//   Указываем массивы:                 //
     obj.begin(arr_Data);               // Инициируем возможность чтения/записи данных массива arr_Data по шине I2C.
     obj.writeMask(arr_Mask);           // Указываем маскировочный массив (arr_Mask) флаги которого разрешают запись в массив данных arr_Data.
}                                       // Если не обращаться к функции writeMask(), то все элементы массива arr_Data будут доступны для записи.
                                        //
void loop(){                            //
//   Выводим значения массива данных:   //
     Serial.print("Массив: ");          //
     for(int i=0; i<10; i++){           // Выводим значение каждого из 10 элементов массива данных arr_Data,
         Serial.print(arr_Data[i]);     // если мастер их изменит по шине I2C, то мы это увидим в мониторе последовательного порта.
         Serial.print(' ');             // Значения 4 и 5 элементов массива arr_Data мы запретили менять мастеру, но меняем их сами.
     }                                  //
     Serial.println('.');               //
//   Меняем значения в массиве данных:  //
     arr_Data[5]++;                     // Увеличиваем значение 5 элемента массива данных arr_Data на 1.
     arr_Data[6]=0;                     // Сбрасываем  значение 6 элемента массива данных arr_Data в 0.
//   Задержка:                          //
     delay(1000);                       // Выполняем задержку, чтоб не захломлять экран монитора и не слишком быстро менять значения 5 и 6 элементов массива arr_Data.
}                                       //

// Теперь мастер, по шине I2C, может обращаться к ведомому с адресом 0x09.
// Мастер может читать любой из 10 регистров этого ведомого. Прочитанными значениями будут данные из соответствующих элементов массива arr_Data.
// Например, при чтении регистра с номером 5, мастер будет получать число увеличивающееся на 1 с каждой секундой.
// Мастер может записать данные в регистры 0-3, 6-9 ведомого, это приведёт к изменению значений в элементах 0-3, 6-9 массива arr_Data соответственно.
// Запись мастером любого значения в регистр с номером 4 не приведёт к изменению 4 элемента массива arr_Data.
// Запись мастером любого значения в регистр с номером 5 не приведёт к изменению 5 элемента массива arr_Data, он продолжит счёт на увеличесние каждую секунду.
// Запись мастером любого значения в регистр с номером 6    приведёт к изменению 6 элемента массива arr_Data, но не более чем на 1 секунду, потом он будет сброшен в 0.

/* ВСЕ ФУНКЦИИ БИБЛИОТЕКИ:            - Библиотека iarduino_I2C_connect разработана для удобства соединения нескольких arduino по шине I2C.
 * 
 * begin( массив данных );            - ФУНКЦИЯ ТОЛЬКО ДЛЯ ВЕДОМОГО. Функцию достаточно вызвать один раз в коде setup().
 *                                      Функция предназначена для инициализации чтения/записи данных указанного массива по шине I2C.
 *                                      Данные указанного массива можно читать и менять как в этом скетче, так и по шине I2C.
 *                                      Мастер обращается к элементам массива данных как к регистрам ведомого,
 *                                      номера элементов этого массива (индексы) совпадают с номерами регистров этого ведомого.
 *                                      Скетч мастера можно создать без библиотеки iarduino_I2C_connect,
 *                                      реализовав чтение/запись обычными функциями библиотеки Wire.
 *
 * writeMask( маскировочный массив ); - ФУНКЦИЯ ТОЛЬКО ДЛЯ ВЕДОМОГО. Функйию достаточно вызвать один раз в коде setup().
 *                                      Функция позволяет ограничить запись в массив данных по шине I2C.
 *                                      Функция принимает маскировочный массив типа bool, данные которого являются флагами.
 *                                      Каждый элемент маскировочного массива является флагом разрешающим мастеру
 *                                      запись в тот же элемент массива данных (в элемент с тем же индексом) см. пример.
 *                                      Если не обращаться к функции writeMask(), то все элементы массива данных
 *                                      будут доступны мастеру, как для чтения, так и для записи.
 *
 * readByte( адрес, регистр );        - ФУНКЦИЯ ТОЛЬКО ДЛЯ МАСТЕРА.
 *                                      Функция позволяет мастеру прочитать один байт по шине I2C от ведомого устройства,
 *                                      даже если это реальное устройство, а не Arduino с библиотекой iarduino_I2C_connect.
 *                                      Функция принимает адрес ведомого устройства на шине I2C (0x01...0x7F) и
 *                                      номер регистра ведомого устройства (0...255), данные которого требуется прочитать.
 *                                      Функция возвращает прочитанный из регистра байт данных.
 *
 * writeByte( адрес, регистр, байт ); - ФУНКЦИЯ ТОЛЬКО ДЛЯ МАСТЕРА.
 *                                      Функция позволяет мастеру записать один байт по шине I2C в регистр ведомого устройства,
 *                                      даже если это реальное устройство, а не Arduino с библиотекой iarduino_I2C_connect.
 *                                      Функция принимает адрес ведомого устройства на шине I2C (0x01...0x7F),
 *                                      номер регистра ведомого устройства (0...255), 
 *                                      байт данных который требуется записать в указанный регистр.
 *                                      Функция возвращает результат операции записи, как функция Wire.endTransmission().
 */